# 正则表达式
## 基本操作
* 连接操作（相邻的字符自动连接）
* 或操作（优先级高于连接操作）
* 闭包操作（将自己重复0次或任意多次，优先级高于连接操作）

## 理论基础
* 解决正则表达式的理论基础是非确定有限状态自动机（类似于 KMP，只是一个节点对应的转换可能有多个）
* 每个字符对应一个节点，而转换对应的是边，所以存在某次匹配卡死在某个节点的情况，只有当到达最终节点的时候，才正式匹配成功
* “（”，“）”，“|”，“*”等状态至少含有一条指出的边
* 转换模式有两种：
    * 当当前状态和字母表中的一个字相对应且文本中的当前字符和该字符匹配，则扫过这个字符并通过黑边到下一个状态
    * 自动机可以通过红边在不经过任意字符的情况下转换成下一个状态
* 在构建 NFA 时，要使用一个栈来处理"(""|"和")",并注意连接边
* 最坏的情况是 MN（也就是暴力匹配子字符串的情况）
* 本算法使用了有向图作为工具

