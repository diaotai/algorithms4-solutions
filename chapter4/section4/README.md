# 有向权重图中两点之间最短路径

## 常规
### 处理该问题的要求
* 所有边皆有向
* 不必所有点都是可达的
* 不应该有边的权重是负的
* 最短边通常不含环
* 最短路径可能不唯一
* 最好不含平行边或自环（虽然代码可以很轻松的处理）

### DijkstraShortestPath Algorithm:
* 首先维护一个最小优先权队列，其中 key 是 点，优先度是距离起点的距离
* 不停的从里面拿出距离起点最近的点，然后遍历从该点出发的路径，看能不能更新另一端点的离起点的距离。如果可以，就把另一端点放入优先权队列中（如果已经在队列中，则调整位置）
* 存在一个 edgeTo 数组用来存放到达不同点的最小距离的上一条边，这样可以拿到整个距离


## 无环最短路径算法
### 特征
* 可以在线性时间解决问题
* 可以处理负权重的边
* 可以处理相关联问题，比如最长路径

### 算法
* 重点是按拓扑排序的顺序处理点，而不是像之前那样处理优先权队列
* 每个点都处理所有从该点出发的边


## 工作时间规划问题
### 特征
* 某些工作必须在某些其它工作完成后才能开始
* 本质上就是最长路径算法

### 算法
* 假设有 n 个点，那么应当建立 2n + 2 个点，其中第 2n 个点是起点，第 2n + 1 个点是终点
* 第 i 个点的起始位置是 i, 终止位置是 i + n, 连接两点边的权重是 所花费的时间
* 每个任务的起始点应该和起点相连，结束点应该和终点相连（两条边的权重都为0）
* 每个限制型任务 v -> w, v 的终结点应该和 w 的起始点相连, 权重为 0
* 之所以选择最长路径，是因为要保证是之前所有的都已经解决完成

## Bellman-Ford algorithm
```
    for (int pass = 0; pass < G.V(); pass++)
        for (int v = 0; v < G.V(); v++)
            for (DirectedEdge e : G.adj(v))
                relax(e);
```
这种方法是可行的，但是没人会用，因为总是会主处理 V E 条边。


## Queue-based Bellman-Ford algorithm
* 本算法基于以下这种理论，当一个 distTo[v] 改变时，必然是它或它之前路径上当 distTo 有变化
* 因此将需要处理当点放入 queue 中，并且不断处理
* 负环检测是非常必要的

## 套现检测
* 利用负环检测